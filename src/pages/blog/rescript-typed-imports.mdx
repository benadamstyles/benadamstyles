---
createdDate: 2021-02-15 20:00:00+01
publishedDate: 2021-02-16 23:00:00+01
title: Typed Imports in ReScript
---

# Typed imports in ReScript

Although the ReScript docs rightly recommend you [keep third party dependencies to a minimum](https://rescript-lang.org/docs/manual/latest/project-structure#third-party-dependencies), sometimes it makes perfect sense to import something from npm. These days, JavaScript and TypeScript developers alike are used to getting the benefits of IDE ["intellisense"](https://code.visualstudio.com/docs/editor/intellisense) and a certain degree of type safety from the [DefinitelyTyped project](https://github.com/DefinitelyTyped/DefinitelyTyped), which provides type definitions for untyped JavaScript packages that are generally high-quality and correct.

While there have been [discussions](https://forum.rescript-lang.org/t/rfc-universal-monorepo-for-rescript-bindings/811) around building something similar for ReScript, it seems clear that there is not currently a huge appetite for going down this route within the community. This means that automatically obtaining the former of these two benefits – intellisense – when working in a **pure ReScript project** is off the table.

However, we _can_ achieve the latter – mostly-type-safe imports – by leveraging the TypeScript ecosystem. In this blog post I'll show how you can set this up fairly simply.

> ReScript is a new programming language which compiles to JavaScript. It has a completely sound static type system based on decades of academic research, and it looks set to compete with TypeScript due to its safety and elegance. To find out more, visit [the documentation](https://rescript-lang.org/docs/manual/latest/introduction) – for the rest of this blog post I will assume a basic understanding of how the language works.

## How it works

The basic steps to achieve typed imports in ReScript are as follows:

1. Set up TypeScript support in your project.
1. Set up [GenType](https://rescript-lang.org/docs/gentype/latest/introduction), using its TypeScript flavour.
1. Install a package from npm which either includes its own type definitions or (less useful but may still provide some safety) has matching type definitions in DefinitelyTyped).
1. Import the package into ReScript using `@genType.import` instead of `@module`.

Arguably, the first of these steps is the hardest, as it will involve enabling all your tooling (linter, bundler etc) to understand TypeScript files. Once that is set up, the rest is straightforward and is explained quite comprehensively below.

## Why?

One of the great benefits of this setup comes with leveraging automatic dependency update services like [Dependabot](https://dependabot.com), [Greenkeeper](https://greenkeeper.io) or [Renovate](https://www.whitesourcesoftware.com/free-developer-tools/renovate/). When you receive a PR from one of these with an updated version of a package, your tests might cover any happy-path functionality changes that might have broken your app, but there is no automatic way to know whether your `external` bindings to this package are still correct.

However, if all of the following are true:

- the package is written in TypeScript, or includes its own type definitions
- you have set up typed imports as explained in this post
- you have a CI build which runs on PRs and includes a type check

then the build will fail and you will know immediately that you should not be merging this PR without updating your bindings.

## Step-by-step guide

Here's a [real example](https://github.com/benadamstyles/rescript-example-project/compare/blog/post/typed-imports), showing a full diff of all the changes below in a basic ReScript project.

If you prefer step-by-step instructions, read on.

### Set up TypeScript

```sh
npm install --save-dev typescript
```

Create your `tsconfig.json` at the root of your project:

```json
{
  // Avoid typechecking *.bs.js files, as they are not well typed
  "include": ["**/*.gen.tsx"],

  "compilerOptions": {
    // We are only type-checking
    "noEmit": true,

    // These settings likely match your environment,
    // although they may need changing
    "moduleResolution": "node",
    "target": "ES2020",
    "strict": true,
    "jsx": "preserve",
    "esModuleInterop": true,
    "resolveJsonModule": true
  }
}
```

### Set up GenType

```sh
npm install --save-dev gentype
```

Add the gentype config fields to your `bsconfig.json`:

```json
{
  "gentypeconfig": {
    "language": "typescript"
  }
}
```

### Install type definitions

You can search to check whether any of your dependencies, which _don't_ supply their own type definitions, have a matching DefinitelyTyped package:

```sh
npm search @types/package-name
```

Alternatively, to find out if a given package supplies its own type definitions, head to https://www.npmjs.com/package/package-name and look for the TS symbol next to the package name title, for example: [polished](https://www.npmjs.com/package/polished).

### Import the package

Finally, you can update your `external`s to use GenType instead:

```diff
- @module("polished")
+ @genType.import("polished")
external lighten: (float, string) => string = "lighten"
```

This import will now be type-checked by TypeScript – if the package types change, and your bindings are no longer correct, you'll find out next time you run [`tsc`](https://github.com/benadamstyles/rescript-example-project/blob/blog/post/typed-imports/package.json#L5)!

> If you want to try it out, [clone the example project](https://github.com/benadamstyles/rescript-example-project), check out the `blog/post/typed-imports` branch and try changing the type signature of the `lighten` function in `Demo.res`. Run `npm run typecheck` and you should see type errors.
